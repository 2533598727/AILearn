<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metropolis-Hastings 算法可视化</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .visualization {
            flex: 1;
            min-width: 600px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .controls {
            flex: 0 0 300px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .explanation {
            background: white;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-bottom: 30px;
        }
        
        .step-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        button {
            background: #4a6ee0;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #3a5bc7;
        }
        
        button:disabled {
            background: #cccccc;
            cursor: not-allowed;
        }
        
        .parameter-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        .value-display {
            display: inline-block;
            margin-left: 10px;
            font-weight: bold;
            color: #4a6ee0;
        }
        
        .status-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            font-family: monospace;
        }
        
        .status-item {
            margin-bottom: 8px;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 400px;
            margin-top: 20px;
        }
        
        canvas {
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        .step-indicator {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .step {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: #e9ecef;
            margin: 0 5px;
            border-radius: 5px;
            transition: all 0.3s;
        }
        
        .step.active {
            background: #4a6ee0;
            color: white;
        }
        
        h2 {
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        h3 {
            margin: 15px 0 10px;
            color: #4a6ee0;
        }
        
        p {
            margin-bottom: 10px;
        }
        
        .formula {
            font-family: 'Cambria Math', serif;
            font-style: italic;
            background: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin: 15px 0;
            text-align: center;
        }
        
        @media (max-width: 900px) {
            .content {
                flex-direction: column;
            }
            
            .visualization, .controls {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Metropolis-Hastings 算法可视化</h1>
            <p class="subtitle">交互式演示马尔可夫链蒙特卡洛采样过程</p>
        </header>
        
        <div class="content">
            <div class="visualization">
                <h2>算法可视化</h2>
                <div class="canvas-container">
                    <canvas id="distributionCanvas" width="600" height="400"></canvas>
                </div>
                
                <div class="step-indicator">
                    <div class="step" id="step1">1. 初始状态</div>
                    <div class="step" id="step2">2. 生成候选点</div>
                    <div class="step" id="step3">3. 计算接受率</div>
                    <div class="step" id="step4">4. 接受/拒绝</div>
                    <div class="step" id="step5">5. 更新状态</div>
                </div>
                
                <div class="step-controls">
                    <button id="prevStep">上一步</button>
                    <button id="nextStep">下一步</button>
                    <button id="autoStep">自动执行</button>
                    <button id="reset">重置</button>
                </div>
            </div>
            
            <div class="controls">
                <h2>参数设置</h2>
                
                <div class="parameter-group">
                    <label for="proposalStd">建议分布标准差: <span id="proposalStdValue" class="value-display">1.0</span></label>
                    <input type="range" id="proposalStd" min="0.1" max="3.0" step="0.1" value="1.0">
                </div>
                
                <div class="parameter-group">
                    <label for="initialState">初始状态: <span id="initialStateValue" class="value-display">0.0</span></label>
                    <input type="range" id="initialState" min="-5" max="5" step="0.1" value="0.0">
                </div>
                
                <div class="parameter-group">
                    <label for="targetMode">目标分布模式:</label>
                    <select id="targetMode">
                        <option value="bimodal">双峰分布</option>
                        <option value="unimodal">单峰分布</option>
                        <option value="skewed">偏态分布</option>
                    </select>
                </div>
                
                <h2>算法状态</h2>
                <div class="status-panel">
                    <div class="status-item">当前状态: <span id="currentState">0.00</span></div>
                    <div class="status-item">候选状态: <span id="candidateState">-</span></div>
                    <div class="status-item">接受率: <span id="acceptanceRatio">-</span></div>
                    <div class="status-item">随机数: <span id="randomValue">-</span></div>
                    <div class="status-item">接受决策: <span id="acceptDecision">-</span></div>
                    <div class="status-item">迭代次数: <span id="iterationCount">0</span></div>
                    <div class="status-item">接受次数: <span id="acceptCount">0</span></div>
                </div>
            </div>
        </div>
        
        <div class="explanation">
            <h2>Metropolis-Hastings 算法详解</h2>
            
            <div id="step1-explanation">
                <h3>步骤 1: 初始状态</h3>
                <p>选择一个初始状态 x₀。这个初始值可以是任意值，但好的初始值可以加快收敛。</p>
                <p class="formula">x₀ = <span id="initialStateFormula">0.0</span></p>
            </div>
            
            <div id="step2-explanation" style="display: none;">
                <h3>步骤 2: 生成候选点</h3>
                <p>从建议分布 q(x'|x) 中生成一个候选点 x'。通常使用对称分布，如正态分布。</p>
                <p class="formula">x' ~ q(x'|x<sub>t</sub>) = N(x<sub>t</sub>, σ²)</p>
                <p>其中 σ 是建议分布的标准差，可以通过上方的滑块调整。</p>
            </div>
            
            <div id="step3-explanation" style="display: none;">
                <h3>步骤 3: 计算接受率</h3>
                <p>计算接受候选点的概率 α。对于对称建议分布，接受率简化为目标分布的概率比：</p>
                <p class="formula">α = min(1, π(x')/π(x<sub>t</sub>))</p>
                <p>其中 π(x) 是目标分布（我们想要采样的分布）。</p>
            </div>
            
            <div id="step4-explanation" style="display: none;">
                <h3>步骤 4: 接受/拒绝决策</h3>
                <p>从均匀分布 U(0,1) 中生成一个随机数 u。如果 u ≤ α，则接受候选点；否则拒绝。</p>
                <p class="formula">x<sub>t+1</sub> = x' 如果 u ≤ α, 否则 x<sub>t+1</sub> = x<sub>t</sub></p>
            </div>
            
            <div id="step5-explanation" style="display: none;">
                <h3>步骤 5: 更新状态</h3>
                <p>根据上一步的决策更新当前状态。无论是否接受候选点，我们都记录当前状态作为一个样本。</p>
                <p>重复步骤 2-5，直到获得足够多的样本。</p>
            </div>
        </div>
    </div>

    <script>
        // 获取DOM元素
        const canvas = document.getElementById('distributionCanvas');
        const ctx = canvas.getContext('2d');
        const prevStepBtn = document.getElementById('prevStep');
        const nextStepBtn = document.getElementById('nextStep');
        const autoStepBtn = document.getElementById('autoStep');
        const resetBtn = document.getElementById('reset');
        const proposalStdSlider = document.getElementById('proposalStd');
        const proposalStdValue = document.getElementById('proposalStdValue');
        const initialStateSlider = document.getElementById('initialState');
        const initialStateValue = document.getElementById('initialStateValue');
        const targetModeSelect = document.getElementById('targetMode');
        
        // 状态显示元素
        const currentStateSpan = document.getElementById('currentState');
        const candidateStateSpan = document.getElementById('candidateState');
        const acceptanceRatioSpan = document.getElementById('acceptanceRatio');
        const randomValueSpan = document.getElementById('randomValue');
        const acceptDecisionSpan = document.getElementById('acceptDecision');
        const iterationCountSpan = document.getElementById('iterationCount');
        const acceptCountSpan = document.getElementById('acceptCount');
        
        // 步骤指示器
        const steps = document.querySelectorAll('.step');
        const stepExplanations = [
            document.getElementById('step1-explanation'),
            document.getElementById('step2-explanation'),
            document.getElementById('step3-explanation'),
            document.getElementById('step4-explanation'),
            document.getElementById('step5-explanation')
        ];
        
        // 算法状态变量
        let currentStep = 0;
        let currentState = 0;
        let candidateState = 0;
        let acceptanceRatio = 0;
        let randomValue = 0;
        let acceptDecision = false;
        let iterationCount = 0;
        let acceptCount = 0;
        let isAutoRunning = false;
        let autoInterval = null;
        
        // 目标分布函数（双峰混合高斯分布）
        function targetDistribution(x) {
            const mode = targetModeSelect.value;
            
            if (mode === 'bimodal') {
                // 双峰分布：两个高斯的混合
                return 0.5 * Math.exp(-0.5 * Math.pow((x - 2) / 1, 2)) / (1 * Math.sqrt(2 * Math.PI)) +
                       0.5 * Math.exp(-0.5 * Math.pow((x + 2) / 1, 2)) / (1 * Math.sqrt(2 * Math.PI));
            } else if (mode === 'unimodal') {
                // 单峰高斯分布
                return Math.exp(-0.5 * Math.pow(x / 1.5, 2)) / (1.5 * Math.sqrt(2 * Math.PI));
            } else if (mode === 'skewed') {
                // 偏态分布（Gamma分布的近似）
                return x >= 0 ? Math.exp(-x/2) * Math.pow(x/2, 2) / 2 : 0;
            }
        }
        
        // 建议分布（对称正态分布）
        function proposalDistribution(current, std) {
            return current + (Math.random() - 0.5) * 2 * std;
        }
        
        // 计算接受率
        function calculateAcceptanceRatio(current, candidate) {
            const currentDensity = targetDistribution(current);
            const candidateDensity = targetDistribution(candidate);
            
            // 避免除以零
            if (currentDensity === 0) return 1;
            
            return Math.min(1, candidateDensity / currentDensity);
        }
        
        // 绘制分布和状态
        function drawDistributions() {
            const width = canvas.width;
            const height = canvas.height;
            const padding = 40;
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;
            
            // 清除画布
            ctx.clearRect(0, 0, width, height);
            
            // 绘制坐标轴
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // 绘制目标分布
            ctx.strokeStyle = '#4a6ee0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            const xMin = -5;
            const xMax = 5;
            const xStep = (xMax - xMin) / plotWidth;
            
            let maxDensity = 0;
            for (let i = 0; i <= plotWidth; i++) {
                const x = xMin + (i / plotWidth) * (xMax - xMin);
                const density = targetDistribution(x);
                if (density > maxDensity) maxDensity = density;
            }
            
            for (let i = 0; i <= plotWidth; i++) {
                const x = xMin + (i / plotWidth) * (xMax - xMin);
                const density = targetDistribution(x);
                const xPixel = padding + i;
                const yPixel = height - padding - (density / maxDensity) * plotHeight;
                
                if (i === 0) {
                    ctx.moveTo(xPixel, yPixel);
                } else {
                    ctx.lineTo(xPixel, yPixel);
                }
            }
            ctx.stroke();
            
            // 绘制建议分布（以当前状态为中心）
            if (currentStep >= 1) {
                ctx.strokeStyle = 'rgba(255, 165, 0, 0.7)';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                
                const proposalStd = parseFloat(proposalStdSlider.value);
                
                for (let i = 0; i <= plotWidth; i++) {
                    const x = xMin + (i / plotWidth) * (xMax - xMin);
                    const density = Math.exp(-0.5 * Math.pow((x - currentState) / proposalStd, 2)) / 
                                   (proposalStd * Math.sqrt(2 * Math.PI));
                    const xPixel = padding + i;
                    const yPixel = height - padding - (density / maxDensity) * plotHeight * 0.5; // 缩小以便查看
                    
                    if (i === 0) {
                        ctx.moveTo(xPixel, yPixel);
                    } else {
                        ctx.lineTo(xPixel, yPixel);
                    }
                }
                ctx.stroke();
            }
            
            // 绘制当前状态
            if (currentStep >= 0) {
                const currentX = padding + ((currentState - xMin) / (xMax - xMin)) * plotWidth;
                const currentY = height - padding;
                
                ctx.fillStyle = '#4a6ee0';
                ctx.beginPath();
                ctx.arc(currentX, currentY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#4a6ee0';
                ctx.font = '14px Arial';
                ctx.fillText('当前状态', currentX - 30, currentY - 10);
            }
            
            // 绘制候选状态
            if (currentStep >= 1) {
                const candidateX = padding + ((candidateState - xMin) / (xMax - xMin)) * plotWidth;
                const candidateY = height - padding;
                
                ctx.fillStyle = '#ff8c00';
                ctx.beginPath();
                ctx.arc(candidateX, candidateY, 8, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#ff8c00';
                ctx.font = '14px Arial';
                ctx.fillText('候选状态', candidateX - 30, candidateY - 10);
            }
            
            // 绘制接受率（步骤3）
            if (currentStep >= 2) {
                const currentX = padding + ((currentState - xMin) / (xMax - xMin)) * plotWidth;
                const currentY = height - padding - (targetDistribution(currentState) / maxDensity) * plotHeight;
                
                const candidateX = padding + ((candidateState - xMin) / (xMax - xMin)) * plotWidth;
                const candidateY = height - padding - (targetDistribution(candidateState) / maxDensity) * plotHeight;
                
                // 绘制连线
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(currentX, currentY);
                ctx.lineTo(candidateX, candidateY);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // 显示接受率
                ctx.fillStyle = '#333';
                ctx.font = '14px Arial';
                ctx.fillText(`接受率: ${acceptanceRatio.toFixed(4)}`, width / 2 - 40, padding + 20);
            }
            
            // 绘制决策（步骤4）
            if (currentStep >= 3) {
                ctx.fillStyle = acceptDecision ? '#28a745' : '#dc3545';
                ctx.font = 'bold 16px Arial';
                ctx.fillText(
                    acceptDecision ? '接受候选点' : '拒绝候选点', 
                    width / 2 - 50, 
                    padding + 50
                );
            }
            
            // 绘制坐标轴标签
            ctx.fillStyle = '#333';
            ctx.font = '14px Arial';
            ctx.fillText('x', width - padding + 5, height - padding + 5);
            ctx.fillText('概率密度', padding - 10, padding - 10);
        }
        
        // 更新步骤指示器
        function updateStepIndicator() {
            steps.forEach((step, index) => {
                if (index === currentStep) {
                    step.classList.add('active');
                    stepExplanations[index].style.display = 'block';
                } else {
                    step.classList.remove('active');
                    stepExplanations[index].style.display = 'none';
                }
            });
            
            // 更新步骤说明中的初始状态公式
            document.getElementById('initialStateFormula').textContent = currentState.toFixed(2);
        }
        
        // 更新状态显示
        function updateStatusDisplay() {
            currentStateSpan.textContent = currentState.toFixed(2);
            candidateStateSpan.textContent = currentStep >= 1 ? candidateState.toFixed(2) : '-';
            acceptanceRatioSpan.textContent = currentStep >= 2 ? acceptanceRatio.toFixed(4) : '-';
            randomValueSpan.textContent = currentStep >= 3 ? randomValue.toFixed(4) : '-';
            acceptDecisionSpan.textContent = currentStep >= 3 ? (acceptDecision ? '接受' : '拒绝') : '-';
            iterationCountSpan.textContent = iterationCount;
            acceptCountSpan.textContent = acceptCount;
        }
        
        // 执行下一步
        function nextStep() {
            if (currentStep < 5) {
                currentStep++;
                
                if (currentStep === 1) {
                    // 步骤1: 生成候选点
                    const proposalStd = parseFloat(proposalStdSlider.value);
                    candidateState = proposalDistribution(currentState, proposalStd);
                } else if (currentStep === 2) {
                    // 步骤2: 计算接受率
                    acceptanceRatio = calculateAcceptanceRatio(currentState, candidateState);
                } else if (currentStep === 3) {
                    // 步骤3: 接受/拒绝决策
                    randomValue = Math.random();
                    acceptDecision = randomValue <= acceptanceRatio;
                } else if (currentStep === 4) {
                    // 步骤4: 更新状态
                    if (acceptDecision) {
                        currentState = candidateState;
                        acceptCount++;
                    }
                    iterationCount++;
                } else if (currentStep === 5) {
                    // 步骤5: 完成一次迭代，准备下一次
                    currentStep = 1; // 回到步骤1，但保留更新后的状态
                    
                    // 生成新的候选点
                    const proposalStd = parseFloat(proposalStdSlider.value);
                    candidateState = proposalDistribution(currentState, proposalStd);
                }
            }
            
            updateStepIndicator();
            updateStatusDisplay();
            drawDistributions();
        }
        
        // 执行上一步
        function prevStep() {
            if (currentStep > 0) {
                currentStep--;
                
                if (currentStep === 0) {
                    // 回到初始状态
                    // 不需要特殊处理
                }
            }
            
            updateStepIndicator();
            updateStatusDisplay();
            drawDistributions();
        }
        
        // 自动执行
        function toggleAutoStep() {
            if (isAutoRunning) {
                clearInterval(autoInterval);
                autoStepBtn.textContent = '自动执行';
                isAutoRunning = false;
            } else {
                autoStepBtn.textContent = '停止';
                isAutoRunning = true;
                autoInterval = setInterval(nextStep, 1000);
            }
        }
        
        // 重置算法
        function resetAlgorithm() {
            currentStep = 0;
            currentState = parseFloat(initialStateSlider.value);
            candidateState = 0;
            acceptanceRatio = 0;
            randomValue = 0;
            acceptDecision = false;
            iterationCount = 0;
            acceptCount = 0;
            
            if (isAutoRunning) {
                clearInterval(autoInterval);
                autoStepBtn.textContent = '自动执行';
                isAutoRunning = false;
            }
            
            updateStepIndicator();
            updateStatusDisplay();
            drawDistributions();
        }
        
        // 事件监听器
        prevStepBtn.addEventListener('click', prevStep);
        nextStepBtn.addEventListener('click', nextStep);
        autoStepBtn.addEventListener('click', toggleAutoStep);
        resetBtn.addEventListener('click', resetAlgorithm);
        
        proposalStdSlider.addEventListener('input', function() {
            proposalStdValue.textContent = this.value;
            drawDistributions();
        });
        
        initialStateSlider.addEventListener('input', function() {
            initialStateValue.textContent = this.value;
            if (currentStep === 0) {
                currentState = parseFloat(this.value);
                updateStatusDisplay();
                drawDistributions();
            }
        });
        
        targetModeSelect.addEventListener('change', function() {
            drawDistributions();
        });
        
        // 初始化
        window.onload = function() {
            resetAlgorithm();
        };
    </script>
</body>
</html>