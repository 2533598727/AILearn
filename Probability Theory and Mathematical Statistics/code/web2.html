<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metropolis-Hastings 算法与分布拟合</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f7fa;
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .content {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .visualization {
            flex: 1;
            min-width: 600px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .controls {
            flex: 0 0 300px;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .sampling-results {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            margin-top: 20px;
        }
        
        .canvas-container {
            position: relative;
            width: 100%;
            height: 300px;
            margin-top: 20px;
        }
        
        canvas {
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        
        button {
            background: #4a6ee0;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background 0.3s;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: #3a5bc7;
        }
        
        .status-panel {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            font-family: monospace;
        }
        
        h2 {
            margin-bottom: 15px;
            color: #2c3e50;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        
        .explanation-box {
            background: #e8f4fd;
            border-left: 4px solid #4a6ee0;
            padding: 15px;
            margin: 20px 0;
            border-radius: 0 5px 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Metropolis-Hastings 算法与分布拟合</h1>
            <p>理解马尔可夫链如何逼近目标分布</p>
        </header>
        
        <div class="content">
            <div class="visualization">
                <h2>采样过程与分布拟合</h2>
                <div class="canvas-container">
                    <canvas id="samplingCanvas" width="800" height="300"></canvas>
                </div>
                
                <div class="step-controls">
                    <button id="step">单步执行</button>
                    <button id="run100">运行100步</button>
                    <button id="run1000">运行1000步</button>
                    <button id="reset">重置</button>
                    <button id="showHistogram">显示/隐藏直方图</button>
                </div>
                
                <div class="explanation-box">
                    <h3>马尔可夫链 vs 拟合分布</h3>
                    <p><strong>马尔可夫链</strong>：采样的序列 x₁, x₂, x₃, ..., xₙ（图中的点）</p>
                    <p><strong>拟合分布</strong>：当链收敛后，样本的经验分布会逼近目标分布</p>
                    <p><strong>关键理解</strong>：我们关心的不是链本身，而是链的<em>平稳分布</em>！</p>
                </div>
            </div>
            
            <div class="controls">
                <h2>参数设置</h2>
                
                <div class="parameter-group">
                    <label for="proposalStd">建议分布标准差: <span id="proposalStdValue">1.0</span></label>
                    <input type="range" id="proposalStd" min="0.1" max="3.0" step="0.1" value="1.0">
                </div>
                
                <div class="parameter-group">
                    <label for="initialState">初始状态: <span id="initialStateValue">0.0</span></label>
                    <input type="range" id="initialState" min="-5" max="5" step="0.1" value="0.0">
                </div>
                
                <div class="parameter-group">
                    <label for="targetMode">目标分布模式:</label>
                    <select id="targetMode">
                        <option value="bimodal">双峰分布</option>
                        <option value="unimodal">单峰分布</option>
                        <option value="skewed">偏态分布</option>
                    </select>
                </div>
                
                <h2>采样统计</h2>
                <div class="status-panel">
                    <div class="status-item">样本数量: <span id="sampleCount">0</span></div>
                    <div class="status-item">接受率: <span id="acceptanceRate">0%</span></div>
                    <div class="status-item">当前状态: <span id="currentState">0.00</span></div>
                    <div class="status-item">样本均值: <span id="sampleMean">0.00</span></div>
                    <div class="status-item">样本方差: <span id="sampleVariance">0.00</span></div>
                    <div class="status-item">ESS（有效样本量）: <span id="effectiveSamples">0</span></div>
                </div>
            </div>
        </div>
        
        <div class="sampling-results">
            <h2>马尔可夫链分析</h2>
            <div class="canvas-container">
                <canvas id="chainCanvas" width="800" height="300"></canvas>
            </div>
            
            <div class="explanation-box">
                <h3>重要概念解释</h3>
                <p><strong>平稳分布</strong>：马尔可夫链收敛后，状态的分布不再随时间变化，这个分布就是平稳分布。</p>
                <p><strong>遍历性</strong>：从任意初始状态出发，链最终都会收敛到平稳分布。</p>
                <p><strong>大数定律</strong>：当样本足够多时，样本均值会收敛到目标分布的期望值。</p>
                <p><strong>有效样本量 (ESS)</strong>：考虑到样本之间的相关性，ESS 衡量了独立样本的等效数量。</p>
            </div>
        </div>
    </div>

    <script>
        // 获取DOM元素
        const samplingCanvas = document.getElementById('samplingCanvas');
        const samplingCtx = samplingCanvas.getContext('2d');
        const chainCanvas = document.getElementById('chainCanvas');
        const chainCtx = chainCanvas.getContext('2d');
        
        const stepBtn = document.getElementById('step');
        const run100Btn = document.getElementById('run100');
        const run1000Btn = document.getElementById('run1000');
        const resetBtn = document.getElementById('reset');
        const showHistogramBtn = document.getElementById('showHistogram');
        
        const proposalStdSlider = document.getElementById('proposalStd');
        const proposalStdValue = document.getElementById('proposalStdValue');
        const initialStateSlider = document.getElementById('initialState');
        const initialStateValue = document.getElementById('initialStateValue');
        const targetModeSelect = document.getElementById('targetMode');
        
        // 状态显示元素
        const sampleCountSpan = document.getElementById('sampleCount');
        const acceptanceRateSpan = document.getElementById('acceptanceRate');
        const currentStateSpan = document.getElementById('currentState');
        const sampleMeanSpan = document.getElementById('sampleMean');
        const sampleVarianceSpan = document.getElementById('sampleVariance');
        const effectiveSamplesSpan = document.getElementById('effectiveSamples');
        
        // 算法状态变量
        let currentState = 0;
        let samples = [];
        let acceptCount = 0;
        let totalSteps = 0;
        let showHistogram = true;
        
        // 目标分布函数
        function targetDistribution(x) {
            const mode = targetModeSelect.value;
            
            if (mode === 'bimodal') {
                return 0.5 * Math.exp(-0.5 * Math.pow((x - 2) / 1, 2)) / (1 * Math.sqrt(2 * Math.PI)) +
                       0.5 * Math.exp(-0.5 * Math.pow((x + 2) / 1, 2)) / (1 * Math.sqrt(2 * Math.PI));
            } else if (mode === 'unimodal') {
                return Math.exp(-0.5 * Math.pow(x / 1.5, 2)) / (1.5 * Math.sqrt(2 * Math.PI));
            } else if (mode === 'skewed') {
                return x >= 0 ? Math.exp(-x/2) * Math.pow(x/2, 2) / 2 : 0;
            }
        }
        
        // 建议分布
        function proposalDistribution(current, std) {
            return current + (Math.random() - 0.5) * 2 * std;
        }
        
        // 执行一步MH采样
        function stepMH() {
            const proposalStd = parseFloat(proposalStdSlider.value);
            const candidate = proposalDistribution(currentState, proposalStd);
            
            const currentDensity = targetDistribution(currentState);
            const candidateDensity = targetDistribution(candidate);
            
            let acceptanceRatio = 1;
            if (currentDensity > 0) {
                acceptanceRatio = Math.min(1, candidateDensity / currentDensity);
            }
            
            const randomValue = Math.random();
            const accepted = randomValue <= acceptanceRatio;
            
            if (accepted) {
                currentState = candidate;
                acceptCount++;
            }
            
            samples.push(currentState);
            totalSteps++;
            
            return accepted;
        }
        
        // 计算统计量
        function calculateStatistics() {
            if (samples.length === 0) return {};
            
            const n = samples.length;
            const mean = samples.reduce((sum, x) => sum + x, 0) / n;
            
            // 计算方差
            const variance = samples.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / (n - 1);
            
            // 简化计算有效样本量 (ESS)
            // 实际应用中应该计算自相关性，这里使用简化版本
            let ess = n;
            if (n > 10) {
                // 基于接受率的简单ESS估计
                const acceptanceRate = acceptCount / totalSteps;
                ess = Math.floor(n * Math.min(1, acceptanceRate * 2));
            }
            
            return {
                mean: mean,
                variance: variance,
                effectiveSamples: ess
            };
        }
        
        // 绘制采样结果
        function drawSamplingResults() {
            const width = samplingCanvas.width;
            const height = samplingCanvas.height;
            const padding = 40;
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;
            
            // 清除画布
            samplingCtx.clearRect(0, 0, width, height);
            
            // 绘制坐标轴
            samplingCtx.strokeStyle = '#ccc';
            samplingCtx.lineWidth = 1;
            samplingCtx.beginPath();
            samplingCtx.moveTo(padding, padding);
            samplingCtx.lineTo(padding, height - padding);
            samplingCtx.lineTo(width - padding, height - padding);
            samplingCtx.stroke();
            
            // 绘制目标分布
            samplingCtx.strokeStyle = '#4a6ee0';
            samplingCtx.lineWidth = 2;
            samplingCtx.beginPath();
            
            const xMin = -5;
            const xMax = 5;
            
            let maxDensity = 0;
            for (let i = 0; i <= plotWidth; i++) {
                const x = xMin + (i / plotWidth) * (xMax - xMin);
                const density = targetDistribution(x);
                if (density > maxDensity) maxDensity = density;
            }
            
            for (let i = 0; i <= plotWidth; i++) {
                const x = xMin + (i / plotWidth) * (xMax - xMin);
                const density = targetDistribution(x);
                const xPixel = padding + i;
                const yPixel = height - padding - (density / maxDensity) * plotHeight;
                
                if (i === 0) {
                    samplingCtx.moveTo(xPixel, yPixel);
                } else {
                    samplingCtx.lineTo(xPixel, yPixel);
                }
            }
            samplingCtx.stroke();
            
            // 绘制样本直方图
            if (showHistogram && samples.length > 0) {
                const histogram = new Array(20).fill(0);
                const binWidth = (xMax - xMin) / 20;
                
                samples.forEach(sample => {
                    if (sample >= xMin && sample <= xMax) {
                        const binIndex = Math.floor((sample - xMin) / binWidth);
                        if (binIndex >= 0 && binIndex < 20) {
                            histogram[binIndex]++;
                        }
                    }
                });
                
                const maxCount = Math.max(...histogram);
                
                samplingCtx.fillStyle = 'rgba(255, 165, 0, 0.5)';
                
                for (let i = 0; i < 20; i++) {
                    const count = histogram[i];
                    if (count > 0) {
                        const barHeight = (count / maxCount) * plotHeight * 0.8;
                        const x = padding + (i / 20) * plotWidth;
                        const barWidth = plotWidth / 20;
                        
                        samplingCtx.fillRect(x, height - padding - barHeight, barWidth, barHeight);
                    }
                }
            }
            
            // 绘制样本点
            if (samples.length > 0) {
                // 只绘制最后200个样本点，避免过于拥挤
                const recentSamples = samples.slice(-200);
                
                samplingCtx.fillStyle = '#ff4757';
                recentSamples.forEach((sample, index) => {
                    const xPixel = padding + ((sample - xMin) / (xMax - xMin)) * plotWidth;
                    const yPixel = height - padding - 5;
                    
                    // 越新的样本颜色越深
                    const opacity = 0.3 + 0.7 * (index / recentSamples.length);
                    samplingCtx.globalAlpha = opacity;
                    samplingCtx.beginPath();
                    samplingCtx.arc(xPixel, yPixel, 3, 0, Math.PI * 2);
                    samplingCtx.fill();
                });
                samplingCtx.globalAlpha = 1.0;
            }
            
            // 绘制当前状态
            const currentX = padding + ((currentState - xMin) / (xMax - xMin)) * plotWidth;
            samplingCtx.fillStyle = '#2ed573';
            samplingCtx.beginPath();
            samplingCtx.arc(currentX, height - padding, 8, 0, Math.PI * 2);
            samplingCtx.fill();
            
            // 添加图例
            samplingCtx.fillStyle = '#333';
            samplingCtx.font = '12px Arial';
            samplingCtx.fillText('目标分布', padding + 10, padding + 20);
            samplingCtx.fillText('样本直方图', padding + 10, padding + 40);
            samplingCtx.fillText('样本点', padding + 10, padding + 60);
            samplingCtx.fillText('当前状态', padding + 10, padding + 80);
            
            samplingCtx.fillStyle = '#4a6ee0';
            samplingCtx.fillRect(padding, padding + 15, 20, 2);
            samplingCtx.fillStyle = 'rgba(255, 165, 0, 0.5)';
            samplingCtx.fillRect(padding, padding + 35, 20, 10);
            samplingCtx.fillStyle = '#ff4757';
            samplingCtx.beginPath();
            samplingCtx.arc(padding + 10, padding + 55, 3, 0, Math.PI * 2);
            samplingCtx.fill();
            samplingCtx.fillStyle = '#2ed573';
            samplingCtx.beginPath();
            samplingCtx.arc(padding + 10, padding + 75, 3, 0, Math.PI * 2);
            samplingCtx.fill();
        }
        
        // 绘制马尔可夫链
        function drawMarkovChain() {
            const width = chainCanvas.width;
            const height = chainCanvas.height;
            const padding = 40;
            const plotWidth = width - 2 * padding;
            const plotHeight = height - 2 * padding;
            
            // 清除画布
            chainCtx.clearRect(0, 0, width, height);
            
            if (samples.length < 2) return;
            
            // 绘制坐标轴
            chainCtx.strokeStyle = '#ccc';
            chainCtx.lineWidth = 1;
            chainCtx.beginPath();
            chainCtx.moveTo(padding, padding);
            chainCtx.lineTo(padding, height - padding);
            chainCtx.lineTo(width - padding, height - padding);
            chainCtx.stroke();
            
            // 绘制链
            chainCtx.strokeStyle = '#4a6ee0';
            chainCtx.lineWidth = 1;
            chainCtx.beginPath();
            
            // 只绘制最多1000个点，避免性能问题
            const step = Math.max(1, Math.floor(samples.length / 1000));
            const displayedSamples = samples.filter((_, index) => index % step === 0);
            
            displayedSamples.forEach((sample, index) => {
                const xPixel = padding + (index / (displayedSamples.length - 1)) * plotWidth;
                const yPixel = height - padding - ((sample + 5) / 10) * plotHeight; // 假设值在-5到5之间
                
                if (index === 0) {
                    chainCtx.moveTo(xPixel, yPixel);
                } else {
                    chainCtx.lineTo(xPixel, yPixel);
                }
            });
            
            chainCtx.stroke();
            
            // 添加标签
            chainCtx.fillStyle = '#333';
            chainCtx.font = '12px Arial';
            chainCtx.fillText('迭代次数', width - padding - 40, height - padding + 20);
            chainCtx.save();
            chainCtx.translate(padding - 20, height / 2);
            chainCtx.rotate(-Math.PI / 2);
            chainCtx.fillText('样本值', 0, 0);
            chainCtx.restore();
            
            // 添加统计信息
            const stats = calculateStatistics();
            chainCtx.fillStyle = '#333';
            chainCtx.font = '14px Arial';
            chainCtx.fillText(`样本数量: ${samples.length}`, padding + 10, padding + 20);
            chainCtx.fillText(`样本均值: ${stats.mean.toFixed(3)}`, padding + 10, padding + 40);
            chainCtx.fillText(`样本方差: ${stats.variance.toFixed(3)}`, padding + 10, padding + 60);
        }
        
        // 更新状态显示
        function updateStatusDisplay() {
            sampleCountSpan.textContent = samples.length;
            const acceptanceRate = totalSteps > 0 ? (acceptCount / totalSteps * 100).toFixed(1) : 0;
            acceptanceRateSpan.textContent = `${acceptanceRate}%`;
            currentStateSpan.textContent = currentState.toFixed(3);
            
            const stats = calculateStatistics();
            sampleMeanSpan.textContent = stats.mean ? stats.mean.toFixed(3) : '0.000';
            sampleVarianceSpan.textContent = stats.variance ? stats.variance.toFixed(3) : '0.000';
            effectiveSamplesSpan.textContent = stats.effectiveSamples || 0;
        }
        
        // 运行多步
        function runSteps(count) {
            for (let i = 0; i < count; i++) {
                stepMH();
            }
            updateStatusDisplay();
            drawSamplingResults();
            drawMarkovChain();
        }
        
        // 重置算法
        function resetAlgorithm() {
            currentState = parseFloat(initialStateSlider.value);
            samples = [];
            acceptCount = 0;
            totalSteps = 0;
            updateStatusDisplay();
            drawSamplingResults();
            drawMarkovChain();
        }
        
        // 事件监听器
        stepBtn.addEventListener('click', () => runSteps(1));
        run100Btn.addEventListener('click', () => runSteps(100));
        run1000Btn.addEventListener('click', () => runSteps(1000));
        resetBtn.addEventListener('click', resetAlgorithm);
        showHistogramBtn.addEventListener('click', () => {
            showHistogram = !showHistogram;
            drawSamplingResults();
        });
        
        proposalStdSlider.addEventListener('input', function() {
            proposalStdValue.textContent = this.value;
        });
        
        initialStateSlider.addEventListener('input', function() {
            initialStateValue.textContent = this.value;
            if (samples.length === 0) {
                currentState = parseFloat(this.value);
                currentStateSpan.textContent = currentState.toFixed(3);
            }
        });
        
        targetModeSelect.addEventListener('change', () => {
            drawSamplingResults();
            drawMarkovChain();
        });
        
        // 初始化
        window.onload = function() {
            resetAlgorithm();
        };
    </script>
</body>
</html>